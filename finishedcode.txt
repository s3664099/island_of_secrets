public class Start {
	
	private static final Logger logger = Logger.getLogger(Start.class.getName());
	
	//Starts the game
	public static void main(String[] args) {

		try {
			
			// Configure the FileHandler to append to the log file
			FileHandler fileHander = new FileHandler("mylog.log",true);
			fileHander.setLevel(Level.ALL);
			logger.addHandler(fileHander);
			
		} catch (Exception e) {
			logger.log(Level.SEVERE, "An error occured while creating the log: "+e.getMessage());
		} 

		try {
			
			//Log the start of the application
			logger.log(Level.INFO, "Starting the game ...");
			
			//Initialise & Start Game
			Main game = new Main();
			game.startGame();
			
			//Log the successful start of the game
			logger.log(Level.INFO, "Game started successfully");
			
		} catch (Exception e) {
			
			//Log the exception with details
			logger.log(Level.SEVERE, "An error occured while starting the game: "+e.getMessage());
			
			System.err.println("Failed to start the game. Please check the logs for more details");
			System.exit(1);
		}
	}
}
public class Constants {

    // Prevent instantiation (private constructor)
    private Constants() {
        throw new UnsupportedOperationException("Constants - Utility class");
    }
	
	//Game related constants
	public static final int NUMBER_OF_ROOMS = 80;
	public static final int NUMBER_OF_ITEMS = 43;
	public static final int NUMBER_OF_VERBS = 42;
	public static final int NUMBER_OF_NOUNS = 52;
	public static final int NUMBER_EXITS = 4;
	
	//Panel Related constants
	public static final int MESSAGE_LENGTH = 60;
	
	//Threshold for item categories in the item list
	public static final int MAX_CARRIABLE_ITEMS = 24; // Items with IDs <= 24 are carriable
	public static final int FOOD_THRESHOLD = 16; // Items with IDs >16 are food
	public static final int DRINK_THRESHOLD = 21; // Items with IDs > 21 are drinks
	public static final int LINE_LENGTH = 90;
	
	//Constants for the Game Class
	public static final int START_LOCATION = 23;
	public static final int RANDOM_ROOM = 39;
	public static final int RANDOM_EXIT_COMBO = 5;
	public static final int NUMBER_RESPONSES = 2;
	
	public static final String NORTH = "North";
	public static final String SOUTH = "South";
	public static final String EAST = "East";
	public static final String WEST = "West";
}
public class Item implements Serializable {
	
	private static final long serialVersionUID = -2697850646469797958L;
	private int itemFlag;
	private int itemLocation;
	private String itemName;
	private boolean wisdomAcquired = false;
	
	private static final int FLAG_OFFSET = 48; // ASCII value of '0'
	private static final int LOCATION_OFFSET = 32; // ASCII value of space
	private static final int LOCATION_ADJUSTMENT = 96; // Adjustment for values > 127
	private static final int ASCII_MAX = 127; // Adjustment for values > 127
	
	/**
     * Constructs an Item with the specified flag, location, and description.
     *
     * @param flag     The flag character (e.g., from ITEM_FLAG).
     * @param location The location character (e.g., from ITEM_LOCATION).
     * @param description The item's description.
     */
	public Item(char flag,char location, String item) {
				
		//Converts the strings to the appropriate int
		this.itemFlag = ((int) flag)-FLAG_OFFSET;
		this.itemLocation = ((int) location)-LOCATION_OFFSET;
		
		
		if (this.itemLocation>ASCII_MAX) {
			this.itemLocation -= LOCATION_ADJUSTMENT;
		}
				
		//Saves the descriptions
		this.itemName = item;
	}
	
	public String getItemName() {
		return this.itemName;
	}
	
	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
	
	public int getItemFlag() {
		return this.itemFlag;
	}
	
	public void setItemFlag(int flag) {
		this.itemFlag = flag;
	}
	
	public int getItemLocation() {
		return this.itemLocation;
	}
	
	public void setItemLocation(int newLocation) {
		this.itemLocation = newLocation;
	}
	
	//Checks if the item is present at the location
	public boolean isAtLocation(int location) {
		
		boolean itemPresent = false;
		
		if (location == this.itemLocation)  {
			itemPresent = true;
		}
		
		return itemPresent;
	}	
			
	public void setWisdomAcquired(boolean wisdonAcquired) {
		this.wisdomAcquired = wisdonAcquired;
	}
	
	public boolean hasWisdonAcquired() {
		return this.wisdomAcquired;
	}
	
    @Override
    public String toString() {
        return "Item{" +
                "description='" + itemName + '\'' +
                ", location=" + itemLocation +
                ", flag=" + itemFlag +
                ", wisdomGained=" + wisdomAcquired +
                '}';
    }
}
public class Location implements Serializable {
	
	private static final long serialVersionUID = 7421397108414613755L;
	
	//Constants for string parsing
	private static final int PREPOSITION_INDEX = 0;
	private static final int NAME_INDEX = 1;
	private static final int EXIT_START_INDEX = 4;
	
	private final String name;
	private final boolean[] exits = new boolean[4];
	private boolean visited = false;
	private boolean viewed = false;
	private String roomType;
	
    /**
     * Constructs a location with the specified name, prepositions, and room type.
     *
     * @param name         The name of the location (e.g., "4the furthest depth of the forest1001").
     * @param prepositions The array of prepositions used to format the name.
     * @param roomType     The type of the room (e.g., "forest", "cave").
     * @throws IllegalArgumentException If the input parameters are invalid.
     */
	public Location(String name, String[] prepositions, String roomType) {		

		//Validate inputs
		if (name == null||name.length()<5) {
			throw new IllegalArgumentException("Invalid name format");
		}
		
		if (prepositions ==  null||prepositions.length==0) {
			throw new IllegalArgumentException("Prepositions array cannot be null or empty");
		}
		
		if (roomType == null||roomType.isEmpty()) {
			throw new IllegalArgumentException("Room type cannot be null or empty");
		}
				
		//Parse the name
		int prep = Integer.parseInt(name.substring(PREPOSITION_INDEX,NAME_INDEX));
		this.name = String.format("%s %s",prepositions[prep-1],name.substring(1,name.length()-EXIT_START_INDEX));
		
		//Parse the exits
		String exitString = name.substring(name.length()-EXIT_START_INDEX);
		for (int i=0;i<4;i++) {
			exits[i] = exitString.charAt(i) == '0';
		}
		
		this.roomType = roomType;
	}
	
	public String getName() {
		return this.name;
	}
	
	public boolean[] getExits() {
		return this.exits;
	}
	
	public void setVisited() {
		this.visited = true;
	}
	
	public boolean getVisited() {
		return this.visited;
	}
	
	public void setViewed() {
		this.viewed = true;
	}
	
	public boolean getViewed() {
		return this.viewed;
	}
	
	public String getRoomType() {
		return this.roomType;
	}
	
	@Override
	public String toString() {
	    return "Location{" +
	            "name='" + name + '\'' +
	            ", exits=" + Arrays.toString(exits) +
	            ", visited=" + visited +
	            ", viewed=" + viewed +
	            ", roomType='" + roomType + '\'' +
	            '}';
	}
}
public class RawData {
	
	
	private static final Integer[] LOCATION_TYPES = {1,1,1,2,13,4,5,6,7,8,
													9,9,10,10,11,12,5,3,14,12,
													9,1,41,41,4,4,16,15,14,16,
													17,17,18,19,1,4,34,16,20,21,
													22,23,22,22,1,24,25,26,16,27,
													16,22,22,28,29,30,31,32,33,22,
													35,36,18,39,30,30,30,33,33,22,
													35,35,18,37,37,37,38,40,9,9};
	
    private static final String[] LOCATION_IMAGE = {"forest","eviltree","pods","cliff","factory",
    										 "vat","battlement","sanctum","cave","bush",
    										 "stone","cloud","paddock","well","hand",
    										 "room","creek","bridge","dunes","here",
    										 "archway","hut","table","nest","castle",
    										 "bones","bookshelf","hill","stonehenge","pyramid",
    										 "island","column","desert","castledoor","flowers",
    										 "brokenchair","village","swamp","stonetree","stumphouse",
    										 "path"};
		    
	private static final String[] LOCATIONS = {
		"4the furthest depth of the forest1001",			// 1  F    1 (Forest)
		"4the depths of the mutant forest1000",				// 2  F    1 (Forest)
		"7a path out of the overground depths1000",			// 3  F    1 (Forest)
		"6a carniverous tree1000",							// 4  CT   2 (Carniverous Tree)
		"4a corral beneath the Crimson Canyon1110",			// 5  Pk  13 (Paddock/Corral)
		"7the top of a steep cliff1011",					// 6  CL   4 (Cliff)  
		"4the marsh factory1001",							// 7  Fc   5 (Factory)
		"4the sludge fermation vats1110",					// 8  Vt   6 (Vat)
		"7the uppermost battlements1001",					// 9  Bt   7 (Battlements)
		"4Omegan's sanctum1110",							//10  Sm   8 (Sanctum
		"4Snelm's lair0001",								//11  C    9 (Cave)
		"2a dark cave0000",									//12  C    9 (Cave)
		"1broken branches0100",								//13  B   10 (Bush)
		"1a thicket of biting bushes0000",					//14  B   10 (Bush)
		"1a huge glassy stone1110",							//15  St  11 (Stone)
		"7the edge of the Crimson Canyon0011",				//16  CL   4 (Cliff)
		"4the clone factory0101",							//17  Fc   5 (Factory)
		"4a corridor of clone storage casks1100",			//18  Pd   3 (Pod)
		"7edge of the well0000",							//19  W   14 (Well)
		"4the Room of Secret Visions1110",					//20  Cl  12 (Cloud)
		"4Snelm's inner chamber0111",						//21  C    9 (Cave)
		"3the southern edge of the forest0101",				//22  F    1 (Forest)
		"7a leafy path1000",								//23  P   43 (Path)
		"3a fork in the path0100",							//24  P   43 (Path)
		"7an apparently unclimable rocky path1100",			//25  CL   4 (Cliff)
		"7a ledge atop the Crimson Canyon0010",				//26  CL   4 (Cliff)
		"4a tall entrance chamber1101",						//27  R   16 (Room)
		"4a low passage with arms reaching from the wall1010",//28 H  15 (Hands)
		"7the approach to the Well of Despair0001",			//29  W   14 (Well)
		"4a dim corridor deep in the castle1010",			//30  R   16 (Room)
		"4the stagnant waters of the crawling creek1001",	//31  Cr  17 (Creek)
		"4a shallow pool off the creek1100",				//32  Cr  17 (Creek)
		"7a log pier, jutting out over the creek0000",		//33  Br  18 (Bridge)
		"4a stretch of featureless dunes1100",				//34  SD  19 (Sand Dunes)
		"1a group of tall trees1010",						//35  F    1 (Forest)
		"7a narrow ledge at the summit of the canyon0011",	//36  CL   4 (Cliff)
		"2a monsterous portal in the castle wall0011",		//37  Bt  34 (Castle Door) 
		"4a chamber inches deep with dust0001",				//38  R   16 (Room)
		"4here!!!!!1111",									//39  !   20 (Exclamation Mark)
		"2a carved archway0010",							//40  Ar  21 (Archway)
		"4a small hut in the log settlement0111",			//41  H   22 (Hut)
		"1a huge split-log table1001",						//42  Tb  23 (Table)
		"4the porch of the logman's cabin0110",				//43  H   22 (Hut)
		"4grandpa's shack1101",								//44  H   22 (Hut)
		"3a clearing in the trees by a rickety shack0010",	//45  F    1 (Forest)
		"4the nest of a huge dactyl0111",					//46  N   24 (Nest)
		"6the Castle of Dark Secrets by two huge stones0011",//47 Cs  25 (Castle)
		"4a room littered with bones0111",					//48  Bn  26 (Bones)
		"4the Cell of Whispered Secrets0111",				//49  R   16 (Room)
		"4the Library of Written Secrets0111",				//50  Bk  27 (Bookshelf)
		"4a refuse strewn storeroom1111",					//51  R   16 (Room)
		"4the Logmen's hall0000",							//52  H   22 (Hut)
		"5a log building1000",								//53  H   22 (Hut)
		"7a rutted hillside1100",							//54  Hl  28 (Hill)
		"7a windswept plain amongst stone megaliths0100",	//55  SH  29 (Stonehenge)
		"7the steps of an ancient pyramid1010",				//56  Py  30 (Pyramid)
		"7the Island of Secrets0111",						//57  Is  31 (Island)
		"1a broken marble column1001",						//58  Co  32 (Column)
		"7an expanse of cracked, baked earth1110",			//59  Ds  33 (Desert)
		"4a deserted abode hut1011",						//60  H   22 (Hut)
		"4a livid growth of mad orchids1011",				//61  Fl  35 (Flowers)
		"4a corner strewn with broken chairs0111",			//62  Ch  36 (Broken Chair)
		"7the bridge near to a log settlement0011",			//63  Br  18 (Bridge)
		"1a crumbling mass of petrified trees1011",			//64  Fs  39 (Stone Trees)
		"3the edge of the pyramid1101",						//65  Py  30 (Pyramid)
		"7the roof of the ancient pyramid0100",				//66  Py  30 (Pyramid)
		"3an impassable split in the pyramid1110",			//67  Py  30 (Pyramid)
		"7a barren blasted wasteland0001",					//68  Ds  33 (Desert)
		"4an expanse of bleak, burnt land1100",				//69  Ds  33 (Desert)
		"5a delapidated abode hut0110",						//70  H   22 (Hut)
		"4the heart of the lillies0101",					//71  Fl  35 (Flowers)
		"4the midst of the lillies1100",					//72  Fl  35 (Flowers)
		"3a river's edge by a log bridge0100",				//73  Br  18 (Bridge)
		"3a petrified village by a river crowded with lillies0100",//74 40 (Village)
		"4the remains of a village1100",					//75  Vi  40 (Village)
		"3the entrance to a petrified village1100",			//76  Vi  40 (Village)
		"4a swamp matted with fibrous roots1100",			//77  Sw  41 (Swamp)
		"2a village of hollow stumps defying the swamp0100",//78  SV  42 (Stump Village)
		"4a tunnel into one of the tree stumps1100",		//79  Cv   9 (Cave)
		"4a hollow chamber many meters in diameter1110"		//80  Cv   9 (Cave)
	};
		
	private static final String[] OBJECTS = {
			
		//Carriable Items
		"a shiny apple",									// 1
		"a fossilised egg",									// 2
		"a lily flower",									// 3
		"an earthenware jug",								// 4
		"a dirty old rag",									// 5
		"a ragged parchment",								// 6
		"a flickering torch",								// 7
		"a blistering pebble",								// 8
		"a woodman's axe",									// 9
		"a coil of rope",									//10
		"a rugged staff",									//11
		"a chip of marble",									//12
		"a polished coal",									//13
		"a piece of flint",									//14
		"a geologist's hammer",								//15
		"a wild canyon beast",								//16
		
		//Food
		"a grain loaf",										//17
		"a juicy melon",									//18
		"some biscuits",									//19
		"a growth of mushrooms",							//20
		
		//Drink
		"a bottle of water",								//21
		"a flagon of wine",									//22
		"a flowing sap",									//23
		"a sparkling freshwater spring",					//24
		
		//Other Items
		"the Boatman",										//25
		"a strapped oak chest",								//26
		"a fracture in the column",							//27
		"a mouth-like opening",								//28
		"an open trapdoor",									//29
		"a parched, dessicated villager",					//30
		"a still of bubbling green liquid",					//31
		"a tough skinned swampman",							//32
		"the Sage of the Lillies",							//33
		"wall after wall of evil books",					//34
		"a number of softer roots",							//35
		"fierce living storm that follows you",				//36
		"malevolent wraiths who push you towards the well",	//37
		"his dreaded cloak of entropy",						//38
		"Omegan the evil one",								//39
		"an immense snake wound around the hut",			//40
		"a group of aggressive logmen",						//41
		"the ancient scavenger","Median"					//42,43
	};
		
	private static final String[] VERBS = {
		"n","s","e","w","go","get","take","give","drop","leave","eat","drink","ride",
		"open","pick","chop","chip","tap","break","fight","strike","attack","hit",
		"kill","swim","shelter","help","scratch","catch","rub","polish","read",
		"examine","fill","say","wait","rest","wave","info","load","save","quit","games"
	};
	
	private static final String[] NOUNS = {
		"apple","egg","flower","jug","rag","parchment","torch","pebble","axe","rope",
		"staff","chip","coal","flint","hammer","beast","loaf","melon","biscuits",
		"mushrooms","bottle","flagon","sap","water","boat","chest","column","opening",
		"trapdoor","villager","liquid","swampman","sage","books","roots","storm","wraiths",
		"cloak","omegan","snake","logmen","scavenger","median","north","south","east","west",
		"up","down","in","out"
	};
			
	private static final String ITEM_LOCATION = "MNgIL5;/U^kZpcL%LJ£5LJm-ALZ/SkIngRm73**MJFF          ";
	private static final String ITEM_FLAG = "90101191001109109000901000111000000100000010000000000";
	private static final String[] PREPOSITIONS = {
		"by","facing","at","in","outside","beneath","on"	
	};
	
	public static String getLocation(int number) {
		
		if (number<0 || number >= LOCATIONS.length) {
			throw new IllegalArgumentException("Raw Data - Invalid location number: "+number);
		}
		
		return LOCATIONS[number];
	}
	
	public static String getImage(int number) {
		
		if (number<0 || number >= LOCATION_TYPES.length) {
			throw new IllegalArgumentException("Raw Data - Invalid location type number: "+number);
		}
		
		return LOCATION_IMAGE[LOCATION_TYPES[number]-1];
	}
	
	public static String getObjects(int number) {
				
		if (number<0 || number >= OBJECTS.length+1) {
			throw new IllegalArgumentException("Raw Data - Invalid object number: "+number);
		}
		
		return OBJECTS[number-1];
	}

	public static String[] getPrepositions() {
		return PREPOSITIONS;
	}
		
	public static char getItemLocation(int number) {
		
		if (number<0 || number >= ITEM_LOCATION.length()) {
			throw new IllegalArgumentException("Raw Data - Invalid object location number: "+number);
		}
		
		return ITEM_LOCATION.charAt(number-1);
	}
	
	public static char getItemFlag(int number) {
		
		if (number<0 || number >= ITEM_FLAG.length()) {
			throw new IllegalArgumentException("Raw Data - Invalid object flag number: "+number);
		}		
		
		return ITEM_FLAG.charAt(number-1);
	}
	
	public static String[] getVerbs() {
		return VERBS;
	}
	
	public static String[] getNouns() {
		return NOUNS;
	}
}
public class Main {
	
	public void startGame()  {

		try {
			
			//Initialises the game data
			Game gameData =  GameInitialiser.initialiseGame();
			Player player = new Player();
			GameEngine game = new GameEngine(gameData,player);
			
			//Launch UI
			SwingUtilities.invokeLater(() -> {
				try {
					new GameFrame(game);
				} catch (Exception e) {
					throw new RuntimeException("Main - Failed to launch game UI: "+e.getMessage());
				}
			});

		} catch (Exception e) {
			System.err.println("Failed to start the game: " + e.getMessage());
		}
	}
}
public class GameInitialiser {

	public static Game initialiseGame() {
		
		int noRooms = Constants.NUMBER_OF_ROOMS;
		int noItems = Constants.NUMBER_OF_NOUNS;
		
		Location[] locations = new Location[noRooms+1];
		locations[0] = null; //Room 0 is unused
		
		//Initialise locations
		for (int roomNumber=1;roomNumber<noRooms;roomNumber++) {
						
			locations[roomNumber+1] = new Location(RawData.getLocation(roomNumber),
												RawData.getPrepositions(),
												RawData.getImage(roomNumber));
		}
		
		//Initialise Items
		Item[] items = new Item[noItems+1];
		items[0] = null; //Item 0 is unused

		//Builds the item objects
		for (int itemNumber=1;itemNumber<=noItems;itemNumber++) {
			
			//Checks the name to give the item
			String itemName = (itemNumber <= Constants.NUMBER_OF_ITEMS)
					? RawData.getObjects(itemNumber):"";
						
			items[itemNumber] = new Item(RawData.getItemFlag(itemNumber),
										 RawData.getItemLocation(itemNumber),
										 itemName);			
		}
				
		return new Game(locations,items,new SpecialExitHandler());
	}
}
public class Game implements Serializable {
	
	private static final long serialVersionUID = 3473676803014192040L;
	private static final Logger logger = Logger.getLogger(Game.class.getName());
	
	private Location[] locationList;
	private Item[] itemList;
	private SpecialExitHandler specialExitHandler = new SpecialExitHandler();
	private SpecialItemHandler specialItemHandler = new SpecialItemHandler();
	private RandomExitHandler randomExitHandler = new RandomExitHandler();
	
	private MessageBuilder normalMessage = new MessageBuilder("Let your quest begin!");
	private MessageBuilder panelMessage = new MessageBuilder();
		
	private String[] commands = {"","",""};
	
	private enum GameState { STARTED, RUNNING, SAVED_GAMES,ENDED }
	private GameState gameState = GameState.STARTED;
	
	private int saveGameCount = 0;
	private int responseRequired = 0;
	private boolean upperLimitSavedGames = false;
	private boolean lowerLimitSavedGames = false;
	private String[] savedGamesDisplayed = {"","","","",""};
	private int apple_count = 3;
	
	public Game(Location[] locations, Item[] items,SpecialExitHandler specialExitHandler) {
		
		this.locationList = locations;
		this.itemList = items;
		this.specialExitHandler = specialExitHandler;
		
		//sets start location
		locationList[Constants.START_LOCATION].setVisited();
		
	}
	
	public String getRoomName(int roomNumber) {
		
	    if (roomNumber < 0 || roomNumber >= locationList.length) {
	        throw new IllegalArgumentException("Invalid room number: " + roomNumber);
	    }
		
		return this.locationList[roomNumber].getName();
	}
	
	//Goes through the items and checks what is present
	public String getItems(int roomNumber) {
		
	    if (roomNumber < 0 || roomNumber >= locationList.length) {
	        throw new IllegalArgumentException("Invalid room number: " + roomNumber);
	    }
		
		String items = specialItemHandler.getSpecialItems(roomNumber, itemList, locationList);
		int count = items.isEmpty() ? 0:1;
				
		//Goes through each of the items
		for (Item item:itemList) {
			if(item != null && item.isAtLocation(roomNumber) && item.getItemFlag()<1) {
				count ++;
				if (count>1) {
					items = String.format("%s, %s",items,item.getItemName());
				} else {
					items = String.format("%s %s",items,item.getItemName());
				}
			}
		}
				
		if (count>0) {
			items = String.format("%s %s","You see:",items);
		}
		
		return items;
	}
	
	//Returns a display of the available exits.
	public String getExits(int roomNumber) {
		
		boolean[] exitNumbers = locationList[roomNumber].getExits();
		String exits = "";
		
		if (roomNumber == Constants.RANDOM_ROOM) {
			exitNumbers = randomExitHandler.generateRandomExits();			
		}
		
		//Checks if the exit is a special exit. If not, displays it normally.
		if (exitNumbers[0] && (specialExitHandler.displayExit(roomNumber,Constants.NORTH))) {
			exits = addExit(Constants.NORTH,exits);
		}
		
		if (exitNumbers[1] && (specialExitHandler.displayExit(roomNumber,Constants.SOUTH))) {
			exits = addExit(Constants.SOUTH,exits);
		}
		
		if (exitNumbers[2] && (specialExitHandler.displayExit(roomNumber,Constants.EAST))) {
			exits = addExit(Constants.EAST,exits);
		}
		
		if (exitNumbers[3] && (specialExitHandler.displayExit(roomNumber,Constants.WEST))) {
			exits = addExit(Constants.WEST,exits);
		}
		
		if (exits.length()>0) {
			exits = String.format("You can go:%s",exits);
		}
		
		return exits;
	}
	
	//Displays the special location.
	public String getSpecialExits(int roomNumber) {
		return specialExitHandler.getSpecialExit(roomNumber, itemList);	
	}
	
	//Checks if it is possible to move through the exit
	public boolean checkExit(int room, int direction) {
		return locationList[room].getExits()[direction];
	}
	
	//Returns the room based on the number passed through
	public Location getRoom(int roomNumber) {
		return locationList[roomNumber];
	}
	
	//Checks to see if an exit has already been added
	private String addExit(String exit, String exits) {
		
		if (exits.length()>0) {
			exits = String.format("%s, %s",exits,exit);
		} else {
			exits = String.format("%s %s",exits,exit);
		}
		
		return exits;
	}
	
	//Retrieves the message
	public List<String> getNormalMessage() {
		return normalMessage.getMessages();
	}
	
	public List<String> getPanelMessage() {
		return panelMessage.getMessages();
	}
			
	//Adds Message
	public void addMessage(String message,boolean clear, boolean isLongMessage ) {
		logger.info("Adding message: " + message);
		
		if (isLongMessage) {
			normalMessage.addLongMessage(message, clear);
		} else {
			normalMessage.addMessage(message, clear);
		}
	}
		
	public void addPanelMessage(String message,boolean clear) {
		logger.info("Adding Panel message: " + message);
		panelMessage.addMessage(message, clear);
	}
	
	public String getCommand(int number) {
		
		if (number<0||number>=commands.length) {
			throw new IllegalArgumentException("Invalid command number: " + number);
		}
		
		return commands[number];
	}
	
	public Item getItem(int itemNumber) {
		
		if (itemNumber<0||itemNumber >=itemList.length) {
			throw new IllegalArgumentException("Invalid item number: " + itemNumber);
		}
		
		return itemList[itemNumber];
	}
	
	//Gets the sum of the item's flag and location
	public int getItemFlagSum(int itemNumber) {
		
		if (itemNumber<0||itemNumber >=itemList.length) {
			throw new IllegalArgumentException("Invalid item number: " + itemNumber);
		}
		
		return itemList[itemNumber].getItemFlag() + itemList[itemNumber].getItemLocation();
	}
				
	//Cycle through number of save games
	public int getCount() {
		return this.saveGameCount;
	}
	
	public void increaseCount() {
		this.saveGameCount++;
	}
	
	public void descreaseCount() {
		this.saveGameCount--;
	}
	
	public void resetCount() {
		this.saveGameCount=0;
	}
	
	//Set the response required for the input
	//0 - Standard Response
	//1 - Give Response
	//2 - Shelter Response
	public void setResponse(int responseType) {
		
	    if (responseType < 0 || responseType >= Constants.NUMBER_RESPONSES) {
	        throw new IllegalArgumentException("Invalid response type: " + responseType);
	    }
		
		this.responseRequired = responseType;
		logger.info("Response type set to: " + responseType);
	}
	
	public int getResponse() {
		return this.responseRequired;
	}
	
	//Checks how many apples left
	public boolean checkApples() {
		
		boolean applesLeft = false;
		
		if (apple_count>0) {
			apple_count --;
			applesLeft = true;
			logger.info("Apple count decreased. Remaining apples: " + apple_count);
		}
		
		return applesLeft;
	}
	
	//Handling saved game display
	public void setUpperLimitSavedGames(boolean moreGames) {
		this.upperLimitSavedGames = moreGames;
		logger.info("More game position set to: " + this.upperLimitSavedGames);
	}
	
	public boolean getUpperLimitSavedGames() {
		return this.upperLimitSavedGames;
	}
	
	public void setLowerLimitSavedGames(boolean lessGames) {
		this.lowerLimitSavedGames = lessGames;
		logger.info("Less game position set to: " + this.lowerLimitSavedGames);
	}
	
	public boolean getLowerLimitSavedGames() {
		return this.lowerLimitSavedGames;
	}
	
	public String[] getDisplayedSavedGames() {
		return this.savedGamesDisplayed;
	}
	
	public void setDisplayedGames(String[] gameDisplayed) {
		this.savedGamesDisplayed = gameDisplayed;
	}	
	
	//Checks and sets Game State
	public void setSavedGameState(boolean display) {
		if (display) {
			gameState = GameState.SAVED_GAMES;
		} else {
			gameState = GameState.RUNNING;
		}
	}
	//Flag to determine whether the game has ended.
	public void setEndGameState() {
		
		logger.info("Game ended.");
		gameState = GameState.ENDED;
	}
	
	public boolean isInitialGameState() {

		boolean started = false;
		if (gameState == GameState.STARTED) {
			gameState = GameState.RUNNING;
			started = true;
		}
		return started;
	}
		
	public boolean isSavedGameState() {
		
		boolean saveGame = false;
		if (gameState == GameState.SAVED_GAMES) {
			saveGame = true;
		}
		return saveGame;
	}
	
	public boolean isEndGameState() {
		
		boolean endGame = false;
		if (gameState == GameState.ENDED) {
			endGame = true;
		}
		return endGame;
	}
}public class MessageBuilder {
	
	private List<String> messages;
	private int maxMessageLength;
	
	//Standard Construction
	public MessageBuilder() {
		this.messages = new ArrayList<>();
		this.maxMessageLength = Constants.MESSAGE_LENGTH; //Default max length
	}
	
	//Initialises with a message
	public MessageBuilder(String message) {
		this.messages = new ArrayList<>();
		this.messages.add(message);
		this.maxMessageLength = Constants.MESSAGE_LENGTH; //Default max length
	}
	
	//Initialises with a custom max length
	public MessageBuilder(int maxMessageLength) {
		this.messages = new ArrayList<>();
		this.maxMessageLength = maxMessageLength;
	}
	
	/**
     * Adds a message to the builder. If the message exceeds the maximum length,
     * it is split into multiple lines at the last space before the limit.
     */
	public void addMessage(String message, boolean clear) {
		
		//Ignores empty or null messages
		if (message != null && !message.isEmpty()) {
			
			//Clears the message if instructed
			if (clear) {
				clearMessages();
			}
			
			//Split the message is if exceeds the max length
			while(message.length() > maxMessageLength) {
				int lastSpace = message.lastIndexOf(" ",maxMessageLength);

				if (lastSpace == -1) {
					
					//No space found, for split at max length
					lastSpace = maxMessageLength;
				}
				messages.add(message.substring(0,lastSpace).trim());
				message = message.substring(lastSpace).trim();
			}
			
			//Adds the remaining part of the message
			if (!message.isEmpty()) {
				messages.add(message);
			}
		}
	}
	
	/**
     * Adds a message that should be concatenated with the last message if possible.
     * If the last message ends with a period, the new message starts on a new line.
     * Otherwise, it is appended with a comma.
     */
    public void addLongMessage(String message, boolean clear) {
    	
    	if (message != null && !message.isEmpty()) {
    		
			//Clears the message if instructed
			if (clear) {
				clearMessages();
			}
    		
    		if (messages.isEmpty()) {
    		
    			//First message, add it directly
    			messages.add(message);
    		} else {
    			
    			//Get last message
    			String lastMessage = messages.get(messages.size()-1);
    			
    			//Determine how to concatenate
    			if (lastMessage.endsWith(".")) {
    				
    				//Start new sentance
    				lastMessage += " " + message; 
    			} else {
    				
    				//Append the current sentance
    				lastMessage += ", " + message;
    			}
    			
    			//Check if the concatenated message exceeds the maximum length
    			if (lastMessage.length() <= maxMessageLength) {
    				
    				//Update the last message
    				messages.set(messages.size()-1, lastMessage);
    			} else {
    				
    				//Split the concatenated message
    				messages.remove(messages.size()-1);
    				addMessage(lastMessage,false);
    			}
    		}
    	}
    	
    }
	
    /**
     * Returns the list of formatted messages.
     */
    public List<String> getMessages() {
        return messages; // Return a copy to prevent external modification
    }

    /**
     * Clears all messages from the builder.
     */
    public void clearMessages() {
        messages.clear();
    }
}
public class Player implements Serializable {
	
	private static final long serialVersionUID = 495300605316911022L;
	private static final Logger logger = Logger.getLogger(Game.class.getName());
	
	private int room = 23;
	private int roomToDisplay = this.room;
	private final Map<String,Object> stats = new HashMap<>();
	private final Random rand = new Random();
	private int panelFlag = 0;
	private boolean isSwimming = false;
		
	private static final int RANDOM_ROOM_TRIGGER = 20;
	
	public Player() {
		
		//Initialize Stats
		stats.put("strength", 100.0f);
		stats.put("wisdom", 35);
		stats.put("timeRemaining",1000);
		stats.put("weight", 0);
		stats.put("food",2);
		stats.put("drink", 2);
	}
	
	public int getDisplayRoom() {
		return this.roomToDisplay;
	}
		
	public int updateDisplayRoom() {
		
		this.roomToDisplay = this.room;
		
		if (this.room == RANDOM_ROOM_TRIGGER) {
			this.roomToDisplay = rand.nextInt(Constants.NUMBER_OF_ROOMS-1)+1;
		}
		
		return this.roomToDisplay;
	}
	
	public void turnUpdateStats() {
		
		int timeRemaining = (int) stats.get("timeRemaining");
		stats.put("timeRemaining", timeRemaining-1);
		
		float strength = (float) stats.get("strength");
		int weight = (int) stats.get("weight");
		stats.put("strength", strength - (weight/Constants.NUMBER_OF_ITEMS+0.1f));
	}
		
	public float getStrengthWisdon() {
		return ((float) stats.get("strength"))+((int) getStat("wisdom"));
	}

	//Getters & Setters
	public int getRoom() {
		return this.room;
	}
	
	public void setRoom(int room) {
		logger.log(Level.INFO, "Player moved to room: " + room);
		this.room = room;
	}
		
	public Object getStat(String statName) {
		return stats.get(statName);
	}
	
	public void setStat(String statName,Object value) {
		stats.put(statName,value);
	}
	
	public void reduceStat(String statName) {
		int stat = (int) stats.get(statName);
		stat --;
		stats.put(statName, stat);
	}
		
	/*     Flag Settings:
	 * 		0 - Normal Screen
	 * 		1 - Give Screen
	 * 		2 - Lightning Flashes 
	 */
	public void setPanelFlag(int panelFlag) {
		
		if (panelFlag<0) {
			throw new IllegalArgumentException("Player - Panel Flag Cannot be less than 0");
		}
		
		this.panelFlag = panelFlag;
	}
	
	public int getPanelFlag() {
		return this.panelFlag;
	}
	
	public void setSwimming(boolean isSwimming) {
		this.isSwimming = isSwimming;
	}
	
	public boolean getSwimming() {
		return this.isSwimming;
	}
		
	//ToString Methods
	public String toStringStatus() {
		return String.format("Strength: %.2f         wisdom: %d", stats.get("strength"),stats.get("wisdom"));
	}

	public String toStringTimeRemaining() {
		return String.format("Time Remaining: %d",stats.get("timeRemaining"));
	}
	
	@Override
	public String toString() {
	    return "Player{" +
	            "room=" + room +
	            ", strength=" + stats.get("strength") +
	            ", wisdom=" + stats.get("wisdom")  +
	            ", timeRemaining=" + stats.get("timeRemaining")  +
	            ", weight=" + stats.get("weight") +
	            ", food=" + stats.get("food") +
	            ", drink=" + stats.get("drink") +
	            '}';
	}
	
}public class RandomExitHandler implements Serializable {

	private static final long serialVersionUID = 3367548012798466733L;
	private Random rand = new Random();
	
	//Generates location's exits from a array randomly
	public boolean[] generateRandomExits() {
		
		boolean[] exitArray = {false,true,false,false,false,true,false,true,true};
		boolean[] randomExits = new boolean[Constants.NUMBER_EXITS];
		int randExit = rand.nextInt(Constants.RANDOM_EXIT_COMBO);
		
		for (int i=0;i<Constants.NUMBER_EXITS;i++) {
			randomExits[i]=exitArray[randExit+i];
		}
		return randomExits;
	}
}public class SpecialExitHandler implements Serializable {

	private static final long serialVersionUID = 7662068425968354288L;

	//Map holds an array of 2 strings - direction & special direction name
	private Map<Integer, String[]> specialExits = new HashMap<Integer, String[]>();

	private int TRAPDOOR = 29;
	private int TRAPDOOR_ROOM = 51;
	private String TRAPDOOR_DESCRIPTION = " and a closed trapdoor in the floor";
	
	public SpecialExitHandler() {
		
		//Load Special Exits
	    specialExits.put(51, new String[]{"","There is a door to the east"});
	    specialExits.put(12, new String[]{"West","You can also go west into the cave"});
	    specialExits.put(53, new String[]{"West","You can also go west into the hut"});
	    specialExits.put(45, new String[]{"West","You can also go west into the hut"});
	    specialExits.put(70, new String[]{"North","You can also go north into the hut"});
	    specialExits.put(37, new String[]{"North","You can also go north into the portal"});
	    specialExits.put(11, new String[]{"North","You can also go north out of the lair"});
	    specialExits.put(41, new String[]{"North","You can also go north out of the hut"});
	    specialExits.put(43, new String[]{"North","You can also go north out of the cabin"});
	    specialExits.put(66, new String[]{"North","You can also go north down of the pyramid"});
	    specialExits.put(60, new String[]{"South","You can go south out of the hut"});
	    specialExits.put(56, new String[]{"South" ,"You can also go south up the pyramid"});
	    specialExits.put(44, new String[]{"East","You can go east out of the shack"});
	    specialExits.put(52, new String[]{"East","You can go east out of the hall"});
	}
	
	public boolean displayExit(int roomNumber,String exit) {
		
		boolean displayExit = true;
		String[] exitDescriptions =  specialExits.getOrDefault(roomNumber, new String[] {"",""});
		
		if (exitDescriptions[0].equals(exit)) {
			displayExit = false;
		}
		
		return displayExit;
	}
	
	public String getSpecialExit(int roomNumber, Item[] itemList) {
		
		String[] exitDescriptions = specialExits.getOrDefault(roomNumber, new String[]{"", ""});
		String baseDescription = exitDescriptions[1];
		
		//Is player in the trapdoor room
		if (roomNumber == TRAPDOOR_ROOM && itemList[TRAPDOOR].getItemFlag() !=0) {
			baseDescription += TRAPDOOR_DESCRIPTION;
		}
		
		return baseDescription;
	}
}public class SpecialItemHandler implements Serializable {

	private static final long serialVersionUID = -3392796825592359959L;

	private Map<Integer, String> itemDescriptions = new HashMap<>();
	
	private int ENTRANCE_CHAMBER = 27;
	private int GRANDPAS_HUT = 44;
	private int PYRAMID = 67;
	private int ABODE_HUT = 60;
	
	private int TORCH = 7;
	private int CHEST = 26;
	private int FLINT = 14;
	
	private int FLAG_HIDDEN = 9;
	
	
	public SpecialItemHandler() {
		itemDescriptions.put(45,"A tree bristling with apples");
		itemDescriptions.put(27,"A torch hanging in a bracket on the wall");
		itemDescriptions.put(44, "A coffee table against the wall, an open oak chest");
		itemDescriptions.put(67,"A piece of flint stuck n the crack");
		itemDescriptions.put(60, "A map, along with a collection of papers which seem to make up a diary");
	}
	
	public String getSpecialItems(int roomNumber,Item[] itemList, Location[] locationList) {
		
		String description = itemDescriptions.getOrDefault(roomNumber,"");
		
		if (roomNumber == GRANDPAS_HUT && itemList[CHEST].getItemFlag() !=1) {
			description = description.split(", ")[0];
		} else if ((roomNumber == ENTRANCE_CHAMBER && (itemList[TORCH].getItemLocation() != ENTRANCE_CHAMBER || itemList[TORCH].getItemFlag() != FLAG_HIDDEN ))
				|| (roomNumber == PYRAMID && (itemList[FLINT].getItemLocation() != PYRAMID || itemList[FLINT].getItemFlag() != FLAG_HIDDEN))
				|| (roomNumber == ABODE_HUT && !locationList[ABODE_HUT].getViewed())) {
			description = "";
		}
		return description;
	}	
}public class Swimming {
	
	private int swimming = 0;
	private int swimPosition = 0;

	public Swimming(int swimming) {
		this.swimming = swimming;
	}
	
	public void swim() {
		this.swimPosition++;
	}
	
	public boolean checkPosition(float strength) {
		
		boolean checked = false;
		
		if ((this.swimming/2)<this.swimPosition && strength>0) {
			checked = true;
		}
		
		return checked;
	}
}

public class GameFrame extends JFrame {

	private static final long serialVersionUID = -5095376582483866399L;

	public GameFrame(GameEngine engine) {
		
		super("Island of Secrets");
		initiliseUI(engine);
	}
	
	private void initiliseUI(GameEngine engine) {

		//kills the window when the 'x' is clicked at the top
		setDefaultCloseOperation(EXIT_ON_CLOSE);
		configureWindow();
		
		GamePanel gamePanel = new GamePanel(engine);
		this.add(gamePanel);
				
		SwingUtilities.invokeLater(() -> {
			gamePanel.setCommandField();
			setVisible(true);
		});
	}
	
	public void configureWindow()  {
		
		//sets the boundaries of the frame.
		setBounds(100,100, 800,600);
		setResizable(false);
		
		//Center
		setLocationRelativeTo(null);
	}
}
public class StatusPanel extends JPanel {
	
	private static final long serialVersionUID = 582607980142319020L;
	private final JLabel timeLabel = new JLabel();
	private final JLabel statusLabel = new JLabel();
	private final GameStateProvider state;
	
	public StatusPanel(GameStateProvider state) {
		this.state = state;
		configureLayout();
		refresh();
	}
	
	private void configureLayout() {
		setLayout(new GridLayout(2, 1));
		setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, Color.black));
		
		//Time Display
		JPanel timePanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		timePanel.add(timeLabel);
		
		//Status Display
		JPanel statusPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		statusPanel.add(statusLabel);
		
		add(timePanel);
		add(statusPanel);
	}
	
	public void refresh() {
		timeLabel.setText(state.getTime());
		statusLabel.setText(state.getStatus());
	}

}





